= Base de Datos I: Trabajo Práctico
Daniela Rages <daniela.rages95@gmail.com>; Melanie Belén Krujoski <melaniekrujoski@gmail.com>; Santiago Gutierrez <santiagogutierrez1905@gmail.com>; 
v1, {12-06-2022}. Docentes Hernán Czemerinski y Hernán Rondelli (COM-01)
:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4

== Introducción

El presente informe tiene como finalidad argumentar lo realizado en el trabajo práctico. El cual constiste en la creación de una base de datos que contiene información relativa a tarjetas de cŕedito.

Para la creación de la base de datos, las tablas, la instancia de los datos, los stored procedures y triggers necesarios para simular y testear dicha base se realizará una aplicación CLI escrita en Go.

Se utilizará una base de datos relacional en PostgreSQL y una base de datos NoSQL con el fin de compararlos. 

== Descripción

La base SQL contiene la lógica y todos los datos necesarios, según el cual dependiendo de la situación de una tarjeta de crédito específica ésta se procesa y almacena en la tabla correspondiente.
A partir de un consumo realizado éste debe autorizarse, según su situación pasará a ser rechazada o efectivamente se convertirá en una compra realizada.
El consumo será rechazado si la tarjeta se encuentra suspendida, anulada, supera el límite de compra, su plazo de vigencia expiró o si el número de la tarjeta y/o código de seguridad sean inválidos.

Se implementa la lógica para detectar fraudes durante la verificación del consumo.
En el cual, se almacena una alerta dependiendo de las siguientes situaciones:
- Si la tarjeta supera su límite de compra dos veces en el mismo día, lo cual hará que se cambie el estado de la tarjeta a suspendida.
- Si se realizan dos consumos en menos de un minuto en dos comercios diferentes con el mismo código postal.
- Si se realizan dos consumos en menos de cinco minutos en dos comercios diferentes con distinto código postal.

Además, cuenta con la opción de generar facturas en base al período, por cliente y por cada tarjeta que posea.
Contando con una cabecera y detalle con los datos correspondientes a la tarjeta, cliente y monto a pagar.

== Implementación

Se encuentran los siguientes archivos .SQL:
- tablas = ejecuta los CREATE TABLE, los cuales crea todas las tablas necesarias para el modelo de datos que requerimos.
- datos = ejecuta los INSERT INTO TABLE, asigna a cada tabla los datos necesarios y correspondientes.
- PK_FK = ejecuta los ALTER TABLE ADD CONSTRAINT para asignarle a cada tabla su PK Y FK correspondiente.
- drop_pk_fk = ejecuta los ALTER TABLE DROP CONSTRAINT los cuales elimina la asignación de su PK y FK a cada tabla.
- SP&T = ejecuta los stored procedures y triggers para autorizar los consumos, generar las alertas y generar los resúmenes de las tarjetas.

Para mostrar lo señalado anteriormente se creó una aplicación CLI escrita en GO, contiene un menú en el cual según la opción que el usuario seleccione, la realiza.
Se crea la base de datos y se conecta con postgres.
Se cargan las tablas, datos, funciones, PKs y FKs mediante la lectura y ejecución de cada archivo.
Para mostrar todos los consumos procesados se utilizaron Querys para llamar a cada una de las funciones y para mostrar en pantalla los datos correspondientes.

Se cuenta además con la opción de mostrar algunos datos de clientes, tarjetas, comercios y compras generados en BoltDB, con el objetivo de comparar la carga de datos en una base relacional con una no relacional.

Pasaremos a explicar un par de funciones importantes:

- createDatabase(): se conecta con postgres, elimina la base de datos tarjetascredito si ya está existiendo, y la crea.
- autorizar_compras(vnrotarjeta char(16), vcodseguridad char(4), vnrocomercio int, vmonto decimal(7, 2))    Toma una fila de la tabla tarjeta, toma sus datos y hace la correspondiente verificación con una serie de ifs si dicha tarjeta es válida, caso contrario inserta la información de la tarjeta en la tabla rechazo. Y devolverá un boolean en false.
 es válida, sus datos se almacenarán en la tabla compra y retornará un boolean en true. 
- generar_resumen(vnrocliente int, aniomes char(6)): se ubica en la fila cliente, por cada cliente toma su tarjeta y recorre cada una de las compras que realizó y los detalles los incerta en detalle. 
Realiza la suma
Luego realiza la suma de todas las compras y la inserta en la tabla cabecera.
- function rechazo_alerta(): trigger en el cual se disparará si ingresa una nueva fila en la tabla rechazo, tomará sus valores y las incertará en alerta.
Además, si la tarjeta fue rechazada dos veces por limite, ademas de se cambiará su estado a suspendida.
- trigger_autorizar_compras(): trigger en el cual toma cada una de las filas de consumo y le aplica la función autorizar_compras.

== Conclusiones

Como conclusión a partir de lo trabajado en el trabajo práctico podemos mencionar que fue de ayuda para aprender en la práctica cómo funciona un modelo de datos, su estructura interna y conexión.
Algo a destacar es que gracias a ésto se pudo ver de forma concreta cómo las PK y FK juegan un rol importante impactando en la ejecución de los stored procedures y triggers.

Observamos la diferencia entre la base de datos relacional y la no relacional. Entre ellas se resalta en que la no relacional al no tener Pks y Fks no aseguran la integridad de los datos. No aportan soporte y consistencia como así lo hace una relacional.

